{"version":3,"sources":["../src/database-connection.js"],"names":["POOLS","DatabaseConnection","constructor","pool","rawClient","connectionString","connect","options","query","close","release","_connect","ConnectionClass","Promise","resolve","reject","db","acquire","err","client","_pool","createPool","params","max","maxConnections","idleTimeoutMillis","reapIntervalMillis","shutdown","connection","Object","keys","drain","destroyAllNow"],"mappings":";;;;;;;;AAAA,MAAMA,QAAQ,EAAd;;AAEA;AACA;AACA;AACA;AACe,MAAMC,kBAAN,CAAyB;AACtCC,cAAYC,IAAZ,EAAkBC,SAAlB,EAA6B;AAC3B,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACD;;AAED,SAAOD,IAAP,CAAYE,gBAAZ,EAA8B;AAC5B;AACD;;AAED,SAAaC,OAAb,CAAqBC,OAArB,EAA8B;AAC5B;;AAD4B;AAE7B;;AAEDC,UAAe;AACb;AACD;;AAEDC,UAAQ;AACN,SAAKN,IAAL,CAAUO,OAAV,CAAkB,KAAKN,SAAvB;AACA,SAAKA,SAAL,GAAiB,IAAjB;AACD;;AAED,SAAaO,QAAb,CAAsBC,eAAtB,EAAuCL,OAAvC,EAAgD;AAAA;AAC9C,aAAO,IAAIM,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,cAAMZ,OAAOS,gBAAgBT,IAAhB,CAAqBI,QAAQS,EAA7B,CAAb;;AAEAb,aAAKc,OAAL,CAAa,UAACC,GAAD,EAAMC,MAAN,EAAiB;AAC5B,cAAID,GAAJ,EAAS;AACP,mBAAOH,OAAOG,GAAP,CAAP;AACD;;AAED,iBAAOJ,QAAQ,IAAIF,eAAJ,CAAoBT,IAApB,EAA0BgB,MAA1B,CAAR,CAAP;AACD,SAND;AAOD,OAVM,CAAP;AAD8C;AAY/C;;AAED,SAAOC,KAAP,CAAaC,UAAb,EAAyBhB,gBAAzB,EAA2C;AACzC,QAAIF,OAAOH,MAAMK,gBAAN,CAAX;;AAEA,QAAIF,QAAQ,IAAZ,EAAkB;AAChB,YAAMmB,SAAS;AACbN,YAAIX,gBADS;AAEbkB,aAAKtB,mBAAmBuB,cAFX;AAGbC,2BAAmBxB,mBAAmBwB,iBAHzB;AAIbC,4BAAoBzB,mBAAmByB;AAJ1B,OAAf;;AAOAvB,aAAOH,MAAMK,gBAAN,IAA0BgB,WAAWC,MAAX,CAAjC;AACD;;AAED,WAAOnB,IAAP;AACD;;AAED,SAAOwB,QAAP,GAAkB;AAChB,SAAK,MAAMC,UAAX,IAAyBC,OAAOC,IAAP,CAAY9B,KAAZ,CAAzB,EAA6C;AAC3C,YAAMG,OAAOH,MAAM4B,UAAN,CAAb;;AAEA,UAAIzB,IAAJ,EAAU;AACRA,aAAK4B,KAAL,CAAW,MAAM;AACf5B,eAAK6B,aAAL;AACD,SAFD;AAGD;AACF;AACF;AAhEqC;;kBAAnB/B,kB;AAmErBA,mBAAmBuB,cAAnB,GAAoC,IAApC;AACAvB,mBAAmBwB,iBAAnB,GAAuC,IAAvC;AACAxB,mBAAmByB,kBAAnB,GAAwC,IAAxC","file":"database-connection.js","sourcesContent":["const POOLS = {};\n\n// Wrap a single connection w/ a query method in an async function.\n// This is used when we need to execute multiple successive queries and make sure\n// they're executed on the *same* connection and not separate connections\n// from the connection pool.\nexport default class DatabaseConnection {\n  constructor(pool, rawClient) {\n    this.pool = pool;\n    this.rawClient = rawClient;\n  }\n\n  static pool(connectionString) {\n    // implement\n  }\n\n  static async connect(options) {\n    // implement\n  }\n\n  query(...args) {\n    // return new PostgresCursor(this, this.rawClient.query(...args));\n  }\n\n  close() {\n    this.pool.release(this.rawClient);\n    this.rawClient = null;\n  }\n\n  static async _connect(ConnectionClass, options) {\n    return new Promise((resolve, reject) => {\n      const pool = ConnectionClass.pool(options.db);\n\n      pool.acquire((err, client) => {\n        if (err) {\n          return reject(err);\n        }\n\n        return resolve(new ConnectionClass(pool, client));\n      });\n    });\n  }\n\n  static _pool(createPool, connectionString) {\n    let pool = POOLS[connectionString];\n\n    if (pool == null) {\n      const params = {\n        db: connectionString,\n        max: DatabaseConnection.maxConnections,\n        idleTimeoutMillis: DatabaseConnection.idleTimeoutMillis,\n        reapIntervalMillis: DatabaseConnection.reapIntervalMillis\n      };\n\n      pool = POOLS[connectionString] = createPool(params);\n    }\n\n    return pool;\n  }\n\n  static shutdown() {\n    for (const connection of Object.keys(POOLS)) {\n      const pool = POOLS[connection];\n\n      if (pool) {\n        pool.drain(() => {\n          pool.destroyAllNow();\n        });\n      }\n    }\n  }\n}\n\nDatabaseConnection.maxConnections = null;\nDatabaseConnection.idleTimeoutMillis = null;\nDatabaseConnection.reapIntervalMillis = null;\n"]}